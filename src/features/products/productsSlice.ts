import axios from 'axios';
// import { AppThunk } from '../../app/store';
import { IProduct } from './types';
import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit';
import type { RootState } from '../../app/store';

export interface ProductsState {
  readonly productList: IProduct[];
  readonly loading: boolean;
  readonly error: string | null;
}

const initialState: ProductsState = {
  productList: [],
  loading: false,
  error: null,
};

export const fetchProductsThunk = createAsyncThunk(
  'products/fetch',
  async (_, { rejectWithValue }) => {
    try {
      const { data } = await axios.get('/api/products');
      return data as IProduct[];
    } catch (err) {
      // Use `err.response.data` as `action.payload` for a `rejected` action,
      // by explicitly returning it using the `rejectWithValue()` utility
      return rejectWithValue(
        err.response && err.response.data?.message
          ? (err.response.data.message as string)
          : (err.message as string)
      );
    }
  }
);

export const productsSlice = createSlice({
  name: 'products',
  initialState,
  reducers: {},
  // these cases are generated by createAsyncThunk, which is not included in the reducers option
  // We can deal with these "outside" cases by including them in extraReducers
  extraReducers: (builder) => {
    builder.addCase(fetchProductsThunk.pending, (state, action) => {
      state.loading = true;
      state.error = null;
    });
    builder.addCase(fetchProductsThunk.fulfilled, (state, action) => {
      state.productList = action.payload;
      state.error = null;
      state.loading = false;
    });
    builder.addCase(fetchProductsThunk.rejected, (state, action) => {
      if (state.loading) {
        state.loading = false;
        state.error = action.payload as string;
      }
    });
  },
});

export const selectProducts = (state: RootState) => state.products;

export default productsSlice.reducer;
